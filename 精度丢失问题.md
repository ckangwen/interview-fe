#JavaScript 
```js
// 加法 =====================
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法 =====================
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004
35.41 * 100 = 3540.9999999999995

// 除法 =====================
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999
```


JS中没有浮点数类型，浮点数和整数都是通过number类型表示
以64位双精度值浮点数，存储所有Number类型值，最多存储64位二进制数
在二进制中64位由3个部分组成

sign bit + exponent + mantissa
S + E + M
S: 符号，1位，表示正负号，0是正数，1是负数
E：指数，11位，表示次方数
M：尾数，52位，用来表示精确度，超出的部分自动进一舍零

![[103ee6a0c5e6471fbdb84c4b0b025b9f~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp]]



0.1 + 0.2 != 0.3
是因为浮点数转换为 二进制 相加，再转为 十进制 ，就是`0.30000000000000004`


(1.335).toFixed(2) == 1.33
浮点数精度和 toFixed 其实属于同一类问题，都是由于浮点数无法精确表示引起的，如下：
(1.335).toPrecision(20); // "1.3349999999999999645"
toFixed() 方法实则是对 1.3349999999999999645 四舍五入保留两位小数

61453901951867050 + 5 == 61453901951867060
大数问题
因为 Javascript 的数字存储使用了 双精度浮点数数据类型，而这一数据类型能够安全存储 (2^53 - 1) 到 -(2^53 - 1) 之间的数值（包含边界值）。

如果计算的数值，超过最大安全整数，则会导致计算结果不准确



> 有些小数转为二进制，会无限循环，在存取的时候会做截取


某些十进制的浮点数，在转换为二进制时，会出现无限循环，计算机在存储的时候，会对无限循环的二进制数进行 0舍1入，当再转换为十进制时，就造成了计算误差

解决
将小数转换为整数，再运算

最后还可以使用第三方库，如`Math.js`、`BigDecimal.js`