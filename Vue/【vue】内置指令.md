#Vue 


### v-on
给元素绑定事件监听器。
- **缩写：**`@`
- **期望的绑定值类型：**`Function | Inline Statement | Object (不带参数)`
- **参数：**`event` (使用对象语法则为可选项)
- **修饰符**
    - `.stop` - 调用 `event.stopPropagation()`。
    - `.prevent` - 调用 `event.preventDefault()`。
    - `.capture` - 在捕获模式添加事件监听器。
    - `.self` - 只有事件从元素本身发出才触发处理函数。
    - `.{keyAlias}` - 只在某些按键下触发处理函数。
    - `.once` - 最多触发一次处理函数。
    - `.left` - 只在鼠标左键事件触发处理函数。
    - `.right` - 只在鼠标右键事件触发处理函数。
    - `.middle` - 只在鼠标中键事件触发处理函数。
    - `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。



### v-bind
动态的绑定一个或多个 attribute，也可以是组件的 prop。
- **缩写：**`:` 或者 `.` (当使用 `.prop` 修饰符)
- **期望：**`any (带参数) | Object (不带参数)`
- **参数：**`attrOrProp (可选的)`
- **修饰符**
    - `.camel` - 将短横线命名的 attribute 转变为驼峰式命名。
    - `.prop` - 强制绑定为 DOM property。3.2+
    - `.attr` - 强制绑定为 DOM attribute。3.2+



### v-model

在表单输入元素或组件上创建双向绑定。
- **期望的绑定值类型**：根据表单输入元素或组件输出的值而变化
- **仅限：**
    - `<input>`
    - `<select>`
    - `<textarea>`
    - components
- **修饰符**
    - `.lazy` 监听 `change` 事件而不是 `input`
    - `.number`- 将输入的合法字符串转为数字
    - `.trim` - 移除输入内容两端空格


### v-slot
用于声明具名插槽或是期望接收 props 的作用域插槽。
- **缩写：**`#`
- **期望的绑定值类型**：能够合法在函数参数位置使用的 JavaScript 表达式。支持解构语法。绑定值是可选的——只有在给作用域插槽传递 props 才需要。
- **参数**：插槽名 (可选，默认是 `default`)
- **仅限：**
    - `<template>`
    - components(用于带有 prop 的单个默认插槽)


### v-pre
跳过该元素及其所有子元素的编译。
- **无需传入**
- **详细信息**
    
    元素内具有 `v-pre`，所有 Vue 模板语法都会被保留并按原样渲染。最常见的用例就是显示原始双大括号标签及内容

### v-once

仅渲染元素和组件一次，并跳过之后的更新。
- **无需传入**
- **详细信息**
    在随后的重新渲染，元素/组件及其所有子项将被当作静态内容并跳过渲染。这可以用来优化更新时的性能。


### v-cloak
用于隐藏尚未完成编译的 DOM 模板。
- **无需传入**
- **详细信息**
    **该指令只在没有构建步骤的环境下需要使用。**
    当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。
    `v-cloak` 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 `[v-cloak] { display: none }` 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。
    
- **示例**
```css
[v-cloak] {
  display: none;
}
```
```vue
<div v-cloak>
  {{ message }}
</div>
```


### v-memo
- **期望的绑定值类型：**`any[]`
- **详细信息**
**缓存一个模板的子树**。在元素和组件上都可以使用。
为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。
如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。举例来说：
```vue
<div v-memo="[valueA, valueB]">
  ...
</div>
```
当组件重新渲染，如果 `valueA` 和 `valueB` 都保持不变，这个 `<div>` 及其子项的所有更新都将被跳过。实际上，甚至虚拟 DOM 的 vnode 创建也将被跳过，因为缓存的子树副本可以被重新使用。

正确指定缓存数组很重要，否则应该生效的更新可能被跳过。`v-memo` 传入空依赖数组 (`v-memo="[]"`) 将与 `v-once` 效果相同。

**与`v-for`一起使用**
`v-memo` 仅用于性能至上场景中的微小优化，应该很少需要。
最常见的情况可能是有助于渲染海量 `v-for` 列表 (长度超过 1000 的情况)：
```vue
<div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
  <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>
  <p>...more child nodes</p>
</div>
```
当组件的 `selected` 状态改变，默认会重新创建大量的 vnode，尽管绝大部分都跟之前是一模一样的。
`v-memo` 用在这里本质上是在说“只有当该项的被选中状态改变时才需要更新”。
这使得每个选中状态没有变的项能完全重用之前的 vnode 并跳过差异比较。
注意这里 memo 依赖数组中并不需要包含 `item.id`，因为 Vue 也会根据 item 的 `:key` 进行判断
> 当搭配 `v-for` 使用 `v-memo`，确保两者都绑定在同一个元素上。**`v-memo` 不能用在 `v-for` 内部。**

