#Vue

Vue2面临的问题
- 随着功能的增长，复杂组件的代码变的难以维护
- 缺少一种比较干净的，在多个组件之间提取和复用逻辑的机制
- 类型推断不友好
- 打包的时间太长

Vue3做了哪些改变
- 更小：移除一些不常用API，引入`tree-shaking`，可以仅打包需要的，使得打包体积变小
- 更快：diff算法优化，模板编译优化，事件监听缓存，SSR优化
- TS支持
- API设计一致性
- 提供自身可维护性：CompositionAPI
- 开放更多底层功能

vue3使用monorepo的方式维护，根据功能将不同的模块拆分到packages目录下面不同的子目录中

使得模块拆分更细，职责划分更明确，模块间的依赖关系更加明确
`Vue3`是基于`typeScript`编写的，提供了更好的类型检查，能支持复杂的类型推导

**vue3的性能提升**
- 体积优化
- 编译优化
- 数据劫持优化

在`vue2`中，数据劫持是通过`Object.defineProperty`，这个 API 有一些缺陷，并不能检测对象属性的添加和删除

`vue3`是通过`proxy`监听整个对象，那么对于删除还是监听当然也能监听到

同时`Proxy` 并不能监听到内部深层次的对象变化，而 `Vue3` 的处理方式是在`getter` 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归

**编译优化**
对静态节点（即不改变的节点）进行编译优化，使用HoistStatic功能将静态节点移动到 render 函数外部进行缓存，从而服务端渲染和提高前端渲染的性能

Patch Flag：在Vue 3.0中，编译的生成vnode会根据节点patch的标记，只对需要重新渲染的数据进行响应式更新，不需要更新的数据不会重新渲染，从而大大提高了渲染性能

静态属性提升：
Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。
免去了重复的创建操作，优化内存。 没做静态提升之前，未参与更新的元素也在render函数内部，会重复创建阶段。  
做了静态提升后，未参与更新的元素，被放置在render 函数外，每次渲染的时候只要取出即可。
同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于 Diff。


事件监听缓存：默认情况下绑定事件行为会被视为动态绑定（`没开启事件监听器缓存`），所以`每次`都会去追踪它的变化。`开启事件侦听器缓存`后，没有了静态标记。也就是说下次`diff算法`的时候`直接使用`。


优化Render function：Vue 3.0的compile优化还包括：Render函数的换行和缩进、Render函数的条件折叠、Render函数的常量折叠等等